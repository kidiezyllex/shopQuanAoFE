function H(u,h){let r;try{r=u()}catch{return}return{getItem:s=>{var e;const c=d=>d===null?null:JSON.parse(d,void 0),l=(e=r.getItem(s))!=null?e:null;return l instanceof Promise?l.then(c):c(l)},setItem:(s,e)=>r.setItem(s,JSON.stringify(e,void 0)),removeItem:s=>r.removeItem(s)}}const S=u=>h=>{try{const r=u(h);return r instanceof Promise?r:{then(n){return S(n)(r)},catch(n){return this}}}catch(r){return{then(n){return this},catch(n){return S(n)(r)}}}},R=(u,h)=>(r,n,s)=>{let e={storage:H(()=>localStorage),partialize:t=>t,version:0,merge:(t,v)=>({...v,...t}),...h},c=!1;const l=new Set,d=new Set;let i=e.storage;if(!i)return u((...t)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),r(...t)},n,s);const y=()=>{const t=e.partialize({...n()});return i.setItem(e.name,{state:t,version:e.version})},_=s.setState;s.setState=(t,v)=>{_(t,v),y()};const f=u((...t)=>{r(...t),y()},n,s);s.getInitialState=()=>f;let m;const I=()=>{var t,v;if(!i)return;c=!1,l.forEach(o=>{var a;return o((a=n())!=null?a:f)});const g=((v=e.onRehydrateStorage)==null?void 0:v.call(e,(t=n())!=null?t:f))||void 0;return S(i.getItem.bind(i))(e.name).then(o=>{if(o)if(typeof o.version=="number"&&o.version!==e.version){if(e.migrate){const a=e.migrate(o.state,o.version);return a instanceof Promise?a.then(p=>[!0,p]):[!0,a]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,o.state];return[!1,void 0]}).then(o=>{var a;const[p,b]=o;if(m=e.merge(b,(a=n())!=null?a:f),r(m,!0),p)return y()}).then(()=>{g==null||g(m,void 0),m=n(),c=!0,d.forEach(o=>o(m))}).catch(o=>{g==null||g(void 0,o)})};return s.persist={setOptions:t=>{e={...e,...t},t.storage&&(i=t.storage)},clearStorage:()=>{i==null||i.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>I(),hasHydrated:()=>c,onHydrate:t=>(l.add(t),()=>{l.delete(t)}),onFinishHydration:t=>(d.add(t),()=>{d.delete(t)})},e.skipHydration||I(),m||f},w=R;export{H as c,w as p};
